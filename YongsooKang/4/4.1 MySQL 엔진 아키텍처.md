[4.1.1 MySQL의 전체 구조](#411-mysql의-전체-구조)
- [4.1.1.1 MySQL 엔진](#4111-mysql-엔진)
- [4.1.1.2 스토리지 엔진](#4112-스토리지-엔진)
    - [MySQL의 스토리지 엔진](#mysql의-스토리지-엔진)
- [4.1.1.3 핸들러 API](#4113-핸들러-API)

[4.1.2 MySQL 스레딩 구조](#412-mysql-스레딩-구조)
- [4.1.2.1 포그라운드 스레드 (클라이언트 스레드)](#4121-포그라운드-스레드-클라이언트-스레드)
- [4.1.2.2 백그라운드 스레드](#4122-백그라운드-스레드)

[4.1.3 메모리 할당 및 사용 구조](#413-메모리-할당-및-사용-구조)
- [4.1.3.1 글로벌 메모리 영역](#4131-글로벌-메모리-영역)
- [4.1.3.2 로컬 메모리 영역](#4132-로컬-메모리-영역)

[4.1.4 플러그인 스토리지 엔진 모델](#414-플러그인-스토리지-엔진-모델)
- [핸들러](#핸들러)

[4.1.5 컴포넌트](#415-컴포넌트)

[4.1.6 쿼리 실행 구조](#416-쿼리-실행-구조)
- [4.1.6.1 쿼리 파서](#4161-쿼리-파서)
- [4.1.6.2 전처리기](#4162-전처리기)
- [4.1.6.3 옵티마이저](#4163-옵티마이저)
- [4.1.6.4 실행 엔진](#4164-실행-엔진)
- [4.1.6.5 핸들러](#4165-핸들러)

[4.1.8 쿼리 캐시](#418-쿼리-캐시)

[4.1.9 스레드 풀 (Percona Server)](#419-스레드-풀-percona-server)

[4.1.10 트랜잭션 지원 메타데이터](#4110-트랜잭션-지원-메타데이터)

[Reference](#reference)

[Q&A](#qa)

---

# 4.1.1 MySQL의 전체 구조
![MySQL 서버의 전체 구조](./img/4.1%20MySQL%20%EC%84%9C%EB%B2%84%EC%9D%98%20%EC%A0%84%EC%B2%B4%20%EA%B5%AC%EC%A1%B0.png)
- MySQL 서버는 크게 MySQL 엔진과 스토리지 엔진으로 구분한다.
- 대부분의 프로그래밍 언어로부터 접근 방법을 지원하여 드라이버를 지원하고, 이를 이용하여 쿼리를 사용할 수 있다.

## 4.1.1.1 MySQL 엔진
> 요청된 SQL 문장을 분석하거나 최적화하는 등 DBMS의 두뇌에 해당하는 처리를 수행한다.
- MySQL 내에 하나의 MySQL 엔진이 존재한다.
- 클라이언트로부터의 접속 및 쿼리 요청을 처리하는 커넥션 핸들러
- SQL 파서 및 전처리기, 쿼리의 최적화된 실행을 위한 옵티마이저

## 4.1.1.2 스토리지 엔진
> 실제 데이터를 디스크 스토리지에서 읽거나 저장한다.
- MySQL 내에 여러 개의 스토리지 엔진이 존재하여 동시에 사용할 수 있다.
- 각 스토리지 엔진은 성능 향상을 위해 키 캐시나 InnoDB 버퍼 풀과 같은 기능을 내장하고 있다.
- ex) `CREATE TABLE test_table (fd1 INT, fd2 INT) ENGINE=INNODB;`
    - InnoDB 스토리지 엔진을 사용하도록 정의

### MySQL의 스토리지 엔진
> MySQL에서 가장 많이 사용되는 스토리지 엔진은 InnoDB, MyISAM이다.
- MyISAM
    - 비-트랜젝션-세이프(non-transactional-safe) 테이블을 관리
    - 트랜잭션 처리가 필요 없고, Read only 기능이 많은 서비스일수록 효율적
    - SELECT가 많은 서비스에 적합
- InnoDB
    - 트랜젝션에 안전한 테이블을 제공하는 트랜잭션-세이프 스토리지 엔진
    - 트랜잭션 처리가 필요하고, 대용량의 데이터를 다루는 부분에서 효율적
    - 데이터의 변화가 많은 서비스에 적합

## 4.1.1.3 핸들러 API
> 데이터를 쓰거나 읽을 때 각 스토리지 엔진에 쓰기 or 읽기를 요청할때 사용되는 API
- InnoDB가 핸들러 API를 통해 MySQL엔진과 데이터를 주고받는다.
- 상태변수에 작업 처리 횟수를 저장하고, 이를 조회할 수 있다.
    - `SHOW GLOBAL STATUS LIKE 'Handler%';`
- 작업 처리 횟수를 초기화할 수도 있다.
    - `flush status;`

# 4.1.2 MySQL 스레딩 구조
![MySQL의 스레딩 모델](./img/4.2%20MySQL%EC%9D%98%20%EC%8A%A4%EB%A0%88%EB%94%A9%20%EB%AA%A8%EB%8D%B8.png)
- MySQL 서버는 프로세스 기반이 아니라 스레드 기반으로 작동한다.
- 포그라운드 (Foreground) 스레드와 백그라운드 (Background) 스레드로 구분한다.
- MySQL 서버에서 실행 중인 스레드의 목록을 쿼리로 확인할 수 있다.
    - `SELECT thread_id, name, type, processlist_user, processlist_host FROM performance_schema.threads ORDER BY type, thread_id;`

## 4.1.2.1 포그라운드 스레드 (클라이언트 스레드)
> MySQL 서버에 접속된 클라이언트의 수만큼 존재하여 클라이언트가 요청하는 쿼리 문장을 처리한다.
- 클라이언트가 커넥션을 종료하면 해당 스레드는 다시 스레드 캐시로 돌아간다.
    - 이미 스레드 캐시에 일정 갯수 이상의 스레드가 대기중이면 해당 스레드를 종료한다.
    - 스레드 캐시에 유지할 수 있는 최대 스레드 갯수는 `thread_cache_size` 시스템 변수로 설정한다.
- 데이터를 MySQL의 데이터 버퍼나 캐시로부터 가져온다.
- 버퍼나 캐시에 없는 경우 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와서 작업을 처리한다.
    - MyISAM 테이블은 디스크 쓰기 작업까지 포그라운드 스레드가 처리한다.
    - InnoDB 테이블은 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리하고, 나머지 쓰기 작업은 백그라운드 스레드가 처리한다.
- 사용자가 요청한 작업을 처리하기 때문에 사용자 스레드라고도 부름

## 4.1.2.2 백그라운드 스레드
- MyISAM에서는 별로 해당사항이 없지만 InnoDB는 여러가지 작업이 처리된다.
    - Insert Buffer를 병합하는 스레드
    - **로그를 디스크로 기록하는 스레드**
    - **InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드**
    - 데이터를 버퍼로 읽어 오는 스레드
    - 잠금이나 데드락을 모니터링하는 스레드
- MySQL 5.5버전부터 변수를 이용하여 데이터 쓰기, 읽기 스레드를 두 개 이상 지정 가능
    - 쓰기 스레드: `innodb_write_io_threads`
    - 읽기 스레드: `innodb_read_io_threads`
- InnoDB
    - 쓰기 작업을 버퍼링해서 일괄처리하는 방식으로 처리한다.
    - 쿼리로 인해 데이터가 완전히 변경될때까지 기다리지 않아도 된다.
- MyISAM
    - 클라이언트 스레드가 쓰기 작업까지 함께 처리하도록 설계되어 있다.
    - 일반적으로 쓰기 버퍼링 기능을 사용할 수 없다.

# 4.1.3 메모리 할당 및 사용 구조
![MySQL의 메모리 사용 및 할당 구조](./img/4.3%20MySQL%EC%9D%98%20%EB%A9%94%EB%AA%A8%EB%A6%AC%20%EC%82%AC%EC%9A%A9%20%EB%B0%8F%20%ED%95%A0%EB%8B%B9%20%EA%B5%AC%EC%A1%B0.png)
- MySQL에서 사용되는 메모리 공간은 크게 글로벌 메모리 영역과 로컬 메모리 영역으로 구분한다.

## 4.1.3.1 글로벌 메모리 영역
- MySQL 서버가 시작되면서 운영체제로부터 메모리가 할당된다.
- 클라이언트 스레드의 수와 무관하게 하나의 메모리 공간이 할당된다.
    - 필요에 따라 2개 이상의 메모리 공간을 할당 받을 수도 있다.
- 생성된 글로벌 영역은 모든 스레드에 의해 공유된다.
- 대표적인 글로벌 메모리 영역
    - 테이블 캐시
    - InnoDB 버퍼 풀
    - InnoDB 어댑티브 해시 인덱스
    - InnoDB 리두 로그 버퍼

## 4.1.3.2 로컬 메모리 영역
- MySQL 서버상에 존재하는 클라이언트 스레드가 쿼리를 처리하는데 사용하는 메모리 영역
    - 클라이언트가 사용하는 메모리 공간으로 클라이언트 스레드라고도 부름
    - 클라이언트 - MySQL 간의 커넥션을 세션이라고 하여 세션 스레드라고도 부름
- 각 클라이언트 스레드별로 독립적으로 할당되며 절대 공유되어 사용되지 않는다.
- 최악의 경우 MySQL 서버가 메모리 부족으로 멈춰버릴 수 있으므로 적절한 메모리 공간을 설정해야 한다.
- 커넥션이 열려있는 동안 계속 할당된 상태로 남아 있는 공간
    - ex) 커넥션 버퍼, 결과버퍼
- 쿼리를 실행하는 순간에만 할당했다가 다시 해제하는 공간
    - ex) 소트 버퍼, 조인 버퍼
- 대표적인 로컬 메모리 영역
    - 정렬 버퍼
    - 조인 버퍼
    - 바이너리 로그 캐시
    - 네트워크 버퍼

# 4.1.4 플러그인 스토리지 엔진 모델
![img](./img/4.4%20MySQL%20%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8%20%EB%AA%A8%EB%8D%B8.png)
- 플러그인으로 제공되는 것들
    - 스토리지 엔진
    - 인증이나 전문 검색 엔진을 위한 검색어 파서
    - 비밀번호 검증과 커넥션 제어
- 기능을 커스텀하게 확정하거나 새로운 기능을 플러그인을 이용해 구현할 수 있다.
- MySQL 서버에서 지원되는 스토리지 엔진 조회
    - `SHOW ENGIES;`
- 스토리지 엔진뿐 아니라 인증 및 전문 검색용 파서와 같은 플러그인도 조회
    - `SHOW PLUGINS;`

![img](./img/4.5%20MySQL%20%EC%97%94%EC%A7%84%EA%B3%BC%20%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80%20%EC%97%94%EC%A7%84%EC%9D%98%20%EC%B2%98%EB%A6%AC%20%EC%98%81%EC%97%AD.png)
- 쿼리가 실행되는 과정이 위와 같다면 거의 대부분의 작업이 MySQL 엔진에서 처리되고, '데이터 읽기/쓰기' 작업만 스토리지 엔진에서 처리된다.
- 각 처리 영역에서 '데이터 읽기/쓰기' 작업은 대부분 1건의 레코드 단위로 처리된다.
    - ex) 특정 인덱스의 레코드 1건 읽기, 마지막으로 읽은 레코드의 다음/이전 레코드 읽기

## 핸들러
> 어떤 기능에 대해 처리해야 하는 작업을 정의하는 객체
- MySQL 엔진이 각 스토리지 엔진에게 데이터를 읽어오거나 저장하도록 명령하려면 반드시 핸들러를 이용해야 한다.
- 보통 `Handler_`로 시작하는 상태변수를 사용한다.
    - MySQL 엔진이 각 스토리지 엔진에게 보낸 명령의 횟수를 의미하는 변수
- 다른 스토리지 엔진을 사용하는 테이블에 대해 쿼리를 실행하더라도 MySQL의 처리 내용은 대부분 동일하다.
- GROUP BY / ORDER BY 등 복잡한 처리는 스토리지 엔진 영역이 아닌 MySQL 엔진의 처리 영역인 `쿼리 실행기`에서 처리된다.

# 4.1.5 컴포넌트
> MySQL 8.0부터 기존의 플러그인 아키텍처를 대체하기 위해 컴포넌트 아키텍처가 지원된다.
- 기존 MySQL 서버의 플러그인의 단점
    - 플러그인은 오직 MySQL 서버와 인터페이스할 수 있고, 플러그인끼리는 통신할 수 없음
    - 플러그인은 MySQL 서버 변수나 함수를 직접 호출하기 때문에 안전하지 않음 (캡슐화 안됨)
    - 플러그인은 상호 의존 관계를 설정할 수 없어서 초기화가 어려움
- 비밀번호 검증 기능
    - MySQL 5.7버전: 플러그인 형태로 제공
    - MySQL 8.0버전: 컴포넌트에서 제공
        - 설치: `INSTALL COMPONENT 'file://component_validate_password';`
        - 설치된 컴포넌트 확인: `SELECT * FROM mysql.component;`

# 4.1.6 쿼리 실행 구조
![img](./img/4.6%20%EC%BF%BC%EB%A6%AC%20%EC%8B%A4%ED%96%89%20%EA%B5%AC%EC%A1%B0.png)

## 4.1.6.1 쿼리 파서
> 사용자 요청으로 들어온 쿼리 문장을 토큰으로 분리해 트리 형태의 구조로 만들어 내는 작업
- 쿼리 문장의 기본 문법 오류는 이 과정에서 발견되고, 사용자에게 오류 메시지를 전달한다.

## 4.1.6.2 전처리기
> 파서 과정에서 만들어진 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인한다.
- 이 단계에서 각 토큰을 테이블 이름이나 칼럼 이름, 내장 함수와 같은 개체를 매핑해 해당 객체의 존재 여부와 객체의 접근 권한 등을 확인한다.
- 존재하지 않거나 권한이 없는 개체의 토큰은 이 단계에서 걸러진다.

## 4.1.6.3 옵티마이저
> 사용자의 요청으로 들어온 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지를 결정하는 역할을 담당한다.

## 4.1.6.4 실행 엔진
> 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할
- ex) 옵티마이저가 `GROUP BY` 처리를 위해 임시 테이블을 사용하기로 결정했다고 가정
    1. 실행 엔진이 핸들러에게 임시 테이블을 만들라고 요청
    2. 실행 엔진은 WHERE 절에 일치하는 레코드를 읽어오라고 핸들러에게 요청
    3. 읽어온 레코드들을 1번에서 준비한 임시 테이블에 저장하라고 핸들러에게 요청
    4. 데이터가 준비된 임시 테이블에서 필요한 방식으로 데이터를 읽어 오라고 핸들러에게 다시 요청
    5. 최종적으로 실행 엔진은 결과를 사용자나 다른 모듈로 넘김

## 4.1.6.5 핸들러
> MySQL 서버의 가장 밑단에서 MySQL 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 읽어온다.
- 핸들러는 스토리지 엔진을 의미한다.
    - MyISAM 테이블을 조작하는 경우 핸들러가 MyISAM 스토리지 엔진이 된다.
    - InnoDB 테이블을 조작하는 경우 핸들러가 InnoDB 스토리지 엔진이 된다.

# 4.1.8 쿼리 캐시
- 이전의 MySQL
    - SQL 실행 결과를 메모리에 캐시하고, 동일 SQL 쿼리가 실행되면 테이블을 읽지 않고 즉시 결과를 반환하여 빠른 속도를 보임
    - 테이블의 데이터가 변경되면 캐시에 저장된 결과 데이터를 삭제해야 하므로 동시 처리 성능 저하 유발
- MySQL 8.0
    - MySQL 서버의 기능에서 완전히 제거, 관련된 시스템 변수도 모두 제거

# 4.1.9 스레드 풀
> 동시에 실행중인 스레드들을 CPU가 최대한 잘 처리해낼 수 있는 수준으로 줄여서 빨리 처리하게 하는 기능
- MySQL 엔터프라이즈: MySQL 서버 프로그램에 내장되어 있다.
- Percona Server: 플러그인 형태로 작동하게 구현되어 있다.
- MySQL 커뮤니티 에디션에서 사용하려면 동일버전의 Percona Server에서 스레드 풀 플러그인 라이브러리를 설치하여 사용한다.
- 내부적으로 사용자의 요청을 처리하는 스레드 갯수를 줄여서 동시 처리되는 요청이 많다고 해도 MySQL 서버의 CPU가 제한된 갯수의 스레드 처리에만 집중할 수 있게 해서 서버의 자원 소모를 줄이는 것이 목적
- 스케줄링 과정에서 CPU 시간을 제대로 확보하지 못하는 경우에는 쿼리 처리가 더 느려질 수 있다.
- 제한된 수의 스레드만으로 CPU가 처리하도록 적절히 유도한다면
    - CPU의 프로세서 친화도를 높인다.
    - 운영체제 입장에서 불필요한 컨텍스트 스위치를 줄여 오버헤드를 낮춘다.

# 4.1.10 트랜잭션 지원 메타데이터
- ~ MySQL 5.7
    - 테이블의 구조를 FRM 파일에 저장하고 일부 스토어드 프로그램 또한 파일 (*.TRN, *.TRG, *.PAR) 기반으로 관리
    - 이러한 파일 기반의 메타데이터는 생성 및 변경 작업이 트랜잭션을 지원하지 않는다.
        - MySQL 서버가 비정상적으로 종료되면 일관되지 않은 상태가 된다.
- MySQL 8.0 ~
    - 테이블의 구조 정보나 스토어드 프로그램의 코드 관련 정보를 모두 InnoDB의 테이블에 저장한다.
    - 시스템 테이블을 모두 InnoDB 스토리지 엔진을 사용하도록 개선
        - 시스템 테이블: MySQL 서버가 작동하는데 기본적으로 필요한 테이블들
    - InnoDB 스토리지 엔진이 트랜잭션 기반이므로 MySQL 서버가 비정상적으로 종료되도 일관성을 유지한다.

# Reference
- [MySQL 엔진 아키텍처](https://gist.github.com/Dong-Hyeon-Yu/e93bbec55d5303698a6349595dc99b2d)
- [MySQL 아키텍처 훑어보기](https://velog.io/@hdg3052/MySQL-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98#%EC%8A%A4%EB%A0%88%EB%93%9C-%ED%92%80)
- [InnoDB VS MyISAM](https://taeying.tistory.com/entry/MYSQL-InnoDB-VS-MyISAM)
- [핸들러 API](https://velog.io/@j_6367/MYSQL.-Handler-API%EC%99%80-Status)

# Q&A
- 스레드 캐시 관련
- 핸들러와 스토리지 엔진은 다른 개념 아닌가요??
