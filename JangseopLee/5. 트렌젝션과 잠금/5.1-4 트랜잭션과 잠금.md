> 5.1 트랜젝션
> 5.2 MySQL엔진 잠금 /
> 5.3 InnoDB 스토리지 엔진 잠금
> 5.4 격리 수준

## 트렌잭션

-   잠금은 동시성(여러군데서 변경하면 예측 불가!), 트랜젝션은 정합성(원하는 값)을 보장한다
-   트렌젝션을 지원하는 InnoDB, 안하는 MYIsam
-   트렌젝션이 지원되지 않는다면 쿼리 작업의 중간 실패에 대한 조건 처리를 모두 분기해야 할 수도 있다!

-   트렌젝션은 최소한의 범위를 가지는 것이 좋다 -> 여러 트렌젝션으로 쪼개기, 외부통신은 트랜젝션으로 잡지 않기, 불필요한 시점에서 잡지 않기

## 5.2 MySQL 엔진 잠금

-   `글로벌락` : mysql 서버 전반에 걸쳐 db, table 이 달라도 영향 받는다. 여러 데이터베이스에 존재하는 MyIsam이나 Memory 테이블에 대해 덤프(백업) 만들때 사용한다. InnoDB 에서 백업시에 글로벌락이 걸려도 변경 허용하며 백업을 잠시 멈추는 방식으로 바뀌었다
-   `테이블락` : 명시적 묵시적으로 테이블을 잠구는 것으로, 쿼리 실행시에 작동되나, InnoDB의 경우 레코드 잠금을 제공해서 스키마 변경시에만 잠구곤 한다.
-   `네임드락` : 클라인언트간의 상호 동기화를 위해 처리하며, 문자열에 대해 잠금을 진행한다. 자주 쓰이진 않지만, 복잡한 요건으로 레코드 변경시에 데드락을 줄이는 방향으로 사용 될 수 있다.
-   `메타데이터락` : 명시적으로 쓰이진 않으며 테이블의 이름들 등을 바꿀때 원본과 대상을 모두 잠구는 방식으로 일어난다. 운영중인 테이블의 변경시에 InnoDB 트랜젝션과 동시 사용하여 최근데이터를 저장하는 방식으로 변경하는 방식도 있다.

## InnoDB 스토리지 엔진 잠금

    - 스토리지 자체 레코드 기반 잠금방식을 탑재 -> 높은 동시성 처리
    - 레코드와 레코드 사이의 간격을 잠그는 갭락
    - 레코드락 : 인덱스의 레코드를 잠그는 방식 ***
    - 갭락 : 레코드사이에 새로운 레코드 생성을 제어하는 것, 넥스트 키 락의 일부로 주로 사용
    - 넥스트 키락 : 레코드락 + 갭락 -> 바이너리 로그에 기록된 커리가 레플리카 서버에서 실행될때 소스 서버에서 만들ㅇ 낸 결과와 동일하게 만들기 위함
    - 자동 증가락 : autoincrement 속성있는 컬럼테이블 동시 insert 시 테이블 수준의 락이 필요, 5.1 부터 값에 따라 변경가능한데, 0 -모든 insert문장 자동증가락, 1- insert 건수를 예측가능하다면 더 빠른 래치(뮤텍스)를 이용해 처리, 2- 무조건 경량 래치(뮤텍스) 사용한다. 연속된 자동증가값을 보장하진 않으며 인터리빙 모드라고 지칭한다. 동시 처리 능력이 좋아지나, 유니크 값만 보장하고 값이 달라질 수 있다.

-`인덱스와 잠금` : InnoDB는 레코드가 아닌 인덱스를 잠구는 방식으로 인덱스가 없다면 전체 테이블, 혹은 과도한 범위를 잠굴 수 있다. -`레코드 수준의 잠금의 문제` : 테이블 잠금은 쉽게 발견, 해결 될 수 있으나, 자주 사용되지 않는 레코드라면 잘 발견되지 않는다.

## 5.4 격리수준

-   read uncommitted, read committed(오라클), repeatable read(MySQL), serializable (격리정도가 높아지며, 동시처리성이 떨어진다. 단 seariable수준이 아니면 성능 차이는 거의 없다.)
-   R unc : Drity read, non-repeatable read, phantom read
-   R com : non-r, ph
-   Rp re : ph(inno는 제외)
-   serial : 해당사항 없음

-   `RUC` : 커밋안한것도 읽는 방식, 더티 리드, 즉 작업이 완료 되지 않은 변경값도 다른 트랜젝션에서 사용하는 것으로, 격리수준으로 인정 받지 못하기도하는 정합성 문제가 많은 격리수준.
-   `RC` : 변경 후 커밋되지않았다면, 언두 여역에서 데이터를 가져온다. 다만, repeatable read 즉 동일 트렌젝션 내 반복적인 리드에도 같은 결과값을 가져오지 못하는 문제가 발생한다. 타 트랜젝션에서 값을 커밋하는 것에 따라 달라지기 때문. (입금 총 합에 대한 쿼리를 돌린다고 할때 매번 달라지는 문제가 발생 할 수 있다.)
-   `RR` : InnoDB 기본 상태로 바이너리 로그를 가진 mysql 서버에서는 이 수준 이상이 필요. 롤백을 위해 언두로그에 백업하고 실제값을 변경한다 이러한 구조를 MVCC 라고 한다. 리드 커밋티드와의 차이는 언두 영역에 백업된 레코드ㅈ중 어떤 영역을 읽는 가 이다. 트랜젝션 번호보다 작은 값으로 읽는데, 다시말해 내가 트랜젝션 시작하고나서 누가 바꾼건 무시한단 말이다. 또한 정합성 문제가 발생할 수 있는데, 조건에 맞는 값을 다른 트랜젝션에서 추가했을 경우등에 해당한다. 이러한 현상을 PHANTOM READ 라고 한다.
-   `SR` : 가장 단순하고 엄격한 격리수준으로 동시처리성이 떨어진다. 읽기 작업조차 락을 걸게된다. 단 이노디비에서는 팬톤 리드가 갭락과 넥스트 키락 덕분에 일어나지 않으므로 굳이 이 수준까지 사용 할 필요는 없다.
