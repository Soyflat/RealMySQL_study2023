> 8.1 디스크 읽기 방식
> 8.2 인덱스란
> 8.3 B- tree 인덱스 (다중컬럼인덱스)

-   인덱스의 성능은 옵티마이저의 발전에도 불구하고 관리자의 역할로서, 쿼리 튜닝에 중요한 부분이다.

## 8.1 디스크 읽기 방식

-   성능 튜닝과 직접적인 디스크 io
-   랜덤io(hdd sdd 비슷)와 순차io(hdd에서 sdd에 비해 느림)

-   `랜덤io` 디스크에 기록하기 위해 각각의 페이지만큼 시스템 콜 요청이 필요하며,
-   hdd에서는 매 io마다 디스크헤더의 움직이 필요하다. sdd에서도 전체 throughput이 떨어지는 편
-   주로 인덱스 레인지 스캔에 해당.

-   `순차io`에서도 빈번한 동기화 작업은 랜덤io만큼 성능 저하를 일으키며, 이에 기업용들은 RAID컨트롤러의 캐시등으로 효율적 처리한다.
-   큰 테이블의 데부분을 읽을 경우 풀 테이블 스캔-순차IO를 사용하여 빨리 많은 레코드를 읽는다.

-   `쿼리성능개선`은 결국 `랜덤IO`를 줄이는 것이며, 다시말해, `처리에 필요한 데이터`만 읽도록 하는 것이다.

## 8.2 인덱스

-   인덱스는 레코드 주소 - 키 의 쌍으로 빠른 탐색을 가능케 하며, 정렬이 중요하다.

### 자료구조적 분류

-   SortedList : 인덱스, 항상 정렬 유지, 저장시(i,u,d)마다 높은 비용, 빠른 탐색(select) -> 인덱스를 추가한다는 건 저장속도를 감수한다는 것/ 과한 인덱스는 저장용량도 영향
-   ArrayList : 데이터 파일, 저장순서 유지

-   인덱스 : pk - 레코드를 식별할 대표 칼럼, not null, no dup / sk - 세컨더리 인덱스, pk비슷 대체제

### 알고리즘적 분류

-   `B-Tree 인덱스` : 오래되고 발전된 기법, 칼럼 변경 없이 인덱싱, 위치기반으로 발전된게 R-Tree\
-   balanced, 인덱스는 정렬된 상태, 일반적 용도
-   리프 노드 - 데이터 레코드 주소/ 루트, 브렌지 노드 - 자식노드 주소 (이때 데이터 자체는 비정렬적, innoDB는 클러스터링-데이터파일 내부에 비트리가 있는 셈, 때문에 MyISAM은 sk가 물리적주소를 InnoDB는 sk가 논리주소를 가진다, 각각의 장단점이 있다)
-   Hash 인덱스 : 칼럼 값으로 해시값 계산해 인덱식, 빠른 검색, but 값 변경 방식으로 전방일치 등 `값의 일부 검색`이나 `범위 검색`에서는 사용 불가, 메모리기반DB에서 많이 사용

-   unique 조건은 옵티마이저에게는 1개 이상을 찾아야 할지 말지에 대한 중요한 문제
    ㅡ

### 인덱스의 추가 삭제

-   B-Tree 구조에서 새로운 인덱스 키가 추가될때, 리프노드가 꽉 차있다면 리프노드의 split이 이뤄져야 하며, 이때 상위 브랜치 노드까지 처리범위가 늘어난다.
-   일반적으로 쓰기 비용이 1이면 인덱스당 1.5 비용이 추가된다.
-   InnoDB의 경우 인덱스추가 작업을 지연 할 수 있지만 유니크 칼럼은 아니다.

-   InnoDB는 삭제 마킹 후 후 처리하지만, 다른 스토리지 엔진같은 경우 체인지버퍼같은 기능이 없어서 인덱스키 삭제후 쿼리가 돌아간다.(변경은 삭제와 추가의 합)

-   B-Tree 인덱스의 검색은 전체 일치, 앞부분 일치에서만 사용가능하다. 또 연산을 통한(변형된) 정렬이나 검색은 장점을 이용 할 수 없다.
-   특히 이노디비에서는 검색한 인덱스를 잠궈서 레코드를 잠궈, 인덱스가 적절히 없다면 전체를 잠궈버릴 수 도 있다.

### 비트리 인덱스 사용에 미치는 요소

-   페이지(이노디비 스토리지엔진이 디스크에 저장하는 최소단위)는 읽쓰의 최소단위이자, 버퍼링 최소단위이다. 따라서 인덱스도 노드 구분이 페이지 단위이다.
-   인덱스 페이지는 보통 16kb로 16\*1024 / 16(키값 예시크기)+12(자식노드주소예시크기) = 585개 저장 가능하다. -> 이는 쿼리가 레코드 500개를 읽을때마다 디스크 읽기가 발생한다는것.
-   인덱스 키가 커지면 전체적 인덱스 키가 커지고, 인노디비 버퍼풀이나 마이아이삼 키캐시 영역은 한정적이 캐시가능한 레코드 수는 줄어버린다.

-   기수성, 선택도, selectivity, cardinality : 인덱스 키 값 가운데 유니크한 값의 수 -> 중복이 없을 수록 선택도가 높고, 검색이 빨라진다
-   선택도가 낮아도 정렬과 그루핑 작업으로 개선 시킬수도 있다. 인덱스는 항상 검색만을 위한 것이 아니기 때문.
-   `유니크 값` ????

-   인덱스를 이용해 테이블을 읽은건, 그냥 읽는 것에 비해 비용이 높다. -> 일반적 옵티마이저에서는 직접 1건보다 4.5배 비용이 높게 인덱스 통한 읽기를 예측한다. -> 전체의 20% 넘은 내용을 읽으면 인덱스로 읽기는 손해. -> 따라서 힌트를 추가해도 의미 없다.

### 비트리 인덱스로 데이터 읽기

`인덱스 레인지 스캔`

-   다른 것보다 빠른 방식으로, 읽어야하는 범위 결정시 사용. 하지만 이 방식도 데이터 파일에 읽어야하는 갯수만큼 io를 필요하므로 20% 이상 읽어야 할땐 랜덤io보다 직접읽기로 순차io가 나은셈.
    `인덱스 풀 스캔`
-   인텍스의 처음부터 끝까지를 모두 읽는 방식. 데이터 레코드를 모두 읽는거보단 사이즈가 작은 인덱스를 모두 읽는게 저렴 -> 인덱스 명시된 칼럼만으로 처리가 가능할때. 인덱스 레인지보다 느리고 테이블 풀 스캔보단 빠르다.
    `루스 인덱스 스캔`
-   인덱스 레인지,풀 스캔이 타이트 스캔이며 이에 반대되는 개념
-   레인지 스캔과 비슷하게 작동 되나 중간 중간 스킵,
-   group by, max min 에 최적화 하는 경우 사용
    `인덱스 스킵 스캔`
-   루스 인덱스 스캔과 비슷한 방식으로 그룹함수만 사용 되던 것들이 WHERE 조건절 검색에도 사용 되는 확장성을 가진 것이다.
-   루스 인덱스 스캔과 동일하게 인덱스에 무슨 값이 있는지 확인하고, 필요 없는 것들을 스킵하고 넘어가는 방식!

### 다중 칼럼 인덱스

-   일반적 테이블에서는 다중 칼럼을 사용하며, 인덱스의 두번째 칼럼은 첫번째 칼럼에 의존해 정렬된다. 세번째는 두번째에 의존 하는 방식, 따러서 칼럼의 위치가 중요하다.

--end 230509
