# InnoDB

> 로그버퍼 + innoDB 버퍼 풀 + 백그라운드 스레드 (거의 유일하게 레코드 기반 잠금으로 높은 동시성 처리가능)
> ?레코드기반 잠금이란?
> 레코드 기반 잠금(Record-Based Locking)은 데이터베이스에서 동시성 제어를 위해 사용되는 잠금 방법 중 하나입니다. 이 방법은 레코드(데이터베이스에서의 하나의 행)를 읽거나 쓰는 동안 해당 레코드에 대한 다른 트랜잭션의 접근을 제한함으로써 일관성을 유지합니다. 즉, 한 트랜잭션이 레코드에 대한 잠금을 획득하면, 다른 트랜잭션이 해당 레코드를 수정하거나 삭제하는 것을 막아 일관성을 유지할 수 있습니다.

### 프라이머리 키 클러스터링

-   모든 테이블은 프라이머리키 기반 클러스러팅 되어 처리 (세컨더리 인덱스는 레코드 주소x, 프라이머리 키 값을 논리주소로)
    -> pk가 높은 비중으로 쿼리실행계획 구축 (8.8에서 추가로)
    -> MyIsam은 세컨더리랑 pk가 비슷한 비중, 즉 세컨도 rowId(레코드 주소)를 가진다

### FK키 지원

-   MyISAM, 메모리 테이블에선 쓸 수 없는 기능
-   부모 자식 모두 인덱스 설정과 데드락 유발 가능으로 주의
-   긴급한 상황을 위해 끄고 킬 수 있지만, 일관성 체크후 다시 켜야함

```mysql
SET foreign_key_checks=OFF;--global
SET SESSION foreign_key_checks=OFF;
```

?세션과 글로벌의 차이

> 세션은 하나의 커넥션에서 이루어지는 것을 말하며, 글로벌은 말 그대로 여러 사용자, 커넥션에 영향을 끼치는 영역이다.

위 명령어를 통해 얼마나 많은 데이터 작업을 했는지 확인할 수 있다.

### MVCC Multi Version Concurrency Control

> 잠금 없는 일관된 읽기를 위한 기능

-   일반적으로 레코드 레벨의 트렌젝션 지원 dbms 제공
-   언두로그를 이용해 구현
-   멀티버전, 즉 하나의 레코드에 여러 버전이 있다
    -   버퍼 풀 : a -> b
    -   언두로그 : -> a
    -   디스크 : a -> ?(적용시점은 백그라운드 스레드가 알아서)
-   MySQL 시스템 변수인 격리수준이 uncommited냐 commited냐 따라서 언두를 읽어올지, 버퍼를 읽어올지 결정
-   트렌젝션이 길어지면 언두로그 스페이스가 과대해질 수 있다
    ?격리 수준엔 뭐가 있을까

### 자동 데드락 감지

-   이노디비 엔진은 잠금 대기목록을 그래프 형태로 관리한다.
-   교착상태 트렌젝션의 강제 종료 결정은 *언두로그 양*이다.
-   innodb_table_locks 변수 활성시 상위 레이어 MySQL에서 잠근 테이블도 감지 가능하다.
-   동시처리 스레드가 많아지면 _잠금 목록 테이블을 잡고 데드락 스레드를 찾아 서비스 스레드가 멈출수 있다_
    -> innodb_deadlock_detect 변수로 꺼켰 가능 (pk, sk 기반으로 매우 높은 동시성 처리 요구시)
    -> innodb_lock_wait_timeout 을 기본 50초보다 낮게 해서 데드락 감지 안해도 에러 뱉게 하자.

### 자동 장애 복구

-   1 (SRV_FORCE_IGNORE_CORRUPT)
    InnoDB의 테이블 스페이스의 데이터 혹은 인덱스 페이지에 손상된 부분이 발견되어도 무시하고 MySQL 서버를 시작한다.

-   2 (SRV_FORCE_NO_BACKGROUND)
    백그라운드 스레드 가운데 메인 스레드를 시작하지 않고 MySQL 서버를 시작한다.

-   3 (SRV_fORCE_NO_TRX_UNDO)
    커밋되지 않고 종료된 트랜잭션은 계속 그 상태로 유지하며 MySQL 서버를 시작한다.

-   4 (SRV_FORCE_NO_IBUF_MERGE)
    InnoDB 스토리지 엔진이 인서트 버퍼의 내용(병합되지 않은 인덱스 변경 작업 등)을 무시하고 강제로 MySQL 서버를 시작한다.

-   5 (SRV_FORCE_NO_UNDO_LOG_SCAN)
    언두 로그를 모두 무시하고 MySQL 서버를 시작한다.

-   6 (SRV_FORCE_NO_LOG_REDO)
    리두 로그를 모두 무시하고 MySQL 서버를 시작한다.

## InnoDB 버퍼 풀

> 핵심적인 부분, 데이터파일이나, 인덱스 정보 캐싱, 지연으로 일괄 작업 -> 랜덤한 디스크 작업의 감소

-   크기설정 : 운영체제 메모리 공간의 50%에서 점차 올려보는 것이 적당

    -   동적으로 사이즈를 조절 할 수 있지만, 크리티컬하여 한가할때 해야하며, 줄이는건 더더욱 위험
    -   버퍼 풀의 내부 경합을 줄이기 위해 인스턴스로 쪼갤수 있으며 인스턴스당 5GB 가 적당

-   구조 : LRU(MRU) + flush list + free list
    -   LRU는 unused age가 오래되면 삭제되는 구조
    -   플러시 리스트 > 리두로그

### 버퍼풀 성능향상

-   캐싱만이 아니라 버퍼링도 필요
-   리두 로그의 재사용 불가능 공간 = 활성 공간
-   리두로그 재사용 될때마다 LSN이 증가
-   체크포인트 LSN - 마지막 리두로그 LSN = checkpoint age = 활성 리두공간 크기
    버퍼풀 100G - redo log 100MB -> 버퍼링 효과 매우 적음
    버퍼풀 100MB - redo log 100G -> 최대 허용 더티 페이지 100MB

> redo log -> 장애시 버퍼풀 저장데이터 복구 하기 위해, io가 있을때 리두에 저장, check point 개념으로 리두로그파일이 생성
> undo log -> 트렌젝션 실패시에 트렌젝션 전으로의 복구

## 버퍼 풀 플러시

-   8.0 부터 더티페이지 플러시(디스크에 동기화) 안정화
-   플러시 리스트 플러시, LRU 리스트 플러시를 백그라운드에서 동작시켜 성능저하 방지

### 플러시 리스트 플러시

-   리두로그의 재사용을 위해 리두로그를 지워야하는데 더티페이지를 동기화(디스크 입력)해야한다
-   innodb_page_cleaner : 버퍼풀 인스턴스 갯수 이하값으로 동일한게 좋다, 동기화를 담당
-   innodb_max_dirty_page_pct : 버퍼풀의 최대 90% 가지 가질 수 있지만, 때로 너무 높을 수 있어 조절, 기본값 권장
-   innodb_io_capacity : 더티페이지 쓰기 실행 기준
-   innodb_max_dirty_page_pct_lwm : 급격히 증가시 더티페이지 처리, 보통 10%인데 너무 잦으면 높이자.
-   innodb_adaptive_flushing_lwm : 알고리즘으로 더티페이지 생성 속도 조절, 온오프 기능,
-   innodb_flush_neighbor : 디스크 근접 값 같이 쓰기인데 ssd 사용 이후 잘 안씀

### LRU 리스트 플러시

-   사용빈도 낮은 테이터 페이지를 제거하여 클린페이지로 만들고 프리 리스트로 옮긴다.
-   스토리지 엔진의 버퍼풀 최대 스캔 갯수인 innodb_lru_scan_depth에 따른다.

### 버퍼풀 상태 백업 및 복구

-   5.6 이후 부터 버퍼 풀 덤프 및 적재 기능 도입
-   innodb_buffer_pool_dump_now 변수를 통해 백업, innodb_buffer_pool_dump_load_now 복구

```mysql
SET GLOBAL innodb_buffer_pool_dump_now = on; -- 변수를 통해 백업
SET GLOBAL innodb_buffer_pool_dump_load_now =on;-- 복구

SHOW STATUS LIKE 'Innodb_buffer_pool_dump_status'\G  -- 버퍼풀 백업 진행사황
SET GLOBAL innodb_buffer_pool_dump_load_abort =on; -- 백업 중지

~pool_dump_at_shutdown, _at_startup  설정파일에 넣욷면 자동으로

```

### 적재 내용 확인

-   8.0 부터 새로 생긴 기능으로 information_schema 데이터 베이스에 innodb_cashed_indexes 테이블이 추가 되었다.

### mySQL의 격리 수준

MySQL 시스템의 격리수준(Isolation Level)은 동시에 여러 트랜잭션이 수행될 때 발생할 수 있는 문제들을 방지하고 일관성 있는 데이터를 유지하기 위한 설정입니다. MySQL에서 지원하는 격리수준에는 다음과 같은 것들이 있습니다.

READ UNCOMMITTED
가장 낮은 격리수준으로, 다른 트랜잭션이 커밋하지 않은 데이터를 읽을 수 있습니다.
Dirty Read(더러운 읽기)라고도 하며, 데이터 일관성이 보장되지 않습니다.

READ COMMITTED
트랜잭션이 커밋된 데이터만 읽을 수 있습니다.
Non-Repeatable Read(반복 불가능한 읽기) 문제는 발생할 수 있지만, Dirty Read는 발생하지 않습니다.

REPEATABLE READ
트랜잭션이 시작된 시점의 데이터 상태를 유지합니다.
Non-Repeatable Read 문제는 발생하지 않지만, Phantom Read(유령 읽기) 문제는 발생할 수 있습니다.

SERIALIZABLE
가장 높은 격리수준으로, Phantom Read 문제도 발생하지 않습니다.
하지만, 다른 격리수준보다 더 많은 Locking(잠금)이 필요하므로 성능이 떨어질 수 있습니다.
이 중에서도 일반적으로는 REPEATABLE READ를 사용하는 것이 권장됩니다. 하지만, 특정 상황에 따라 다른 격리수준을 사용해야 할 수도 있습니다.

------------ till 2023.03.18 -----------------------------

> Duble write buffer
> about undo log
> about change buffer
> about redo log
> adaptive_hash_index
> storage enginge diff

## 쓰기를 보장하는 Double Write Buffer

    - redo log : 변경된 것만 기록 -> 그럼 변경(더티페이지를 디스크로 플러시) 중에 일부는 실패하면?
    - 일부 실패한 변경 내역 : 파셜페이지, 톤 페이지 라고 불리며 이를 막기 위해 '더블라이팅' 기능 사용
        > 버퍼풀의 더티페이지에 a,b,c 기록 -> double write 버퍼에 기록 -> 성공하면 dw 버퍼는 삭제, 실패하면 사용
    - innodb_boublewrite
    - 순차 쓰기를 하는 hdd에서는 부담이 없지만 순차나 랜덤io나 비슷한 sdd 에선 고려 필요 <-> 데이터 무결성 높힘
    - 서버 성능을 위해 리두로그 동기화를 off 했다면 dw buffer도 off 추천 -> 리두로그 동기화도 안켜고 켜는건 의미 없음

## 트렌젝션을 위해 언두로그

    ### 언두로그란
    - DML 변경 전 이전 undo 한 버전을 저장한 로그
    > 트렌젝션 보장 : 롤백시 사용된다!
    > 격리수준 보장 : 변경 중인 데이터에 조회가 걸릴때 사용 될 수 있다! (격리수준에 따라 다름)

    ### 언두로그 모니터링법
    > 언두로그가 너무 커진다
        - 5.5 이전 버전의 언두로그 공간은 줄지 않아서 100G 테이블을 삭제해도 언두로그에 그 크기의 테이블이 복제되는 셈
        - 트렌젝션이 여러개 동시 일어날때 처음의 트렌젝션이 종료되지 않으면, 그 사이에 커밋된 트렌젝션들도 결국 언두로그를 들고 있어야 한다.
        - 다행이 5.7 이후에는 알아서 공간 정리해준다

```mysql
SHOW ENGINE INNODB STATUS \G
SLELECT count FROM ino~~ --8.0 버전에서 쓸수 있는 명령어로 서버별로 언두로그 건수를 조회 할 수 있다.
--또한  u,d 명령어는 mvcc와 복구 모두에 쓰이지만 i는 롤백에만 쓰기 때문에 언두로그 갯수에 치지 않는다
```

    ### 언두로그의 테이블스페이스
    - 5.6 버전 이전엔 언두로그는 모두 시스템 테이블스페이스에 저장 ibdata.ibd
        > 문제는 시스템 테이블스페이스의 언두로그는 mysql 서버 초기화될때 생성되서 확장의 한계.
        > innodb_undo_tablespaces > 2 로 설정하면 별도의 로그 파일 사용 ( 8.0 부터는 강제 )
    - undo tablespace truncate -> 필요없어진 언두로그 테이블 스페이스 운영체계에 반납, 8버전부터이며
        자동모드는 undo thread가 undo purge 작업을 통해 커밋되어 필요 없어진 언두로그 공간을 반납한다
        수동모드는 명령어로 한번 언두퍼지작업을 하는 셈. 했으면 재 활성화 필요.
    ??아니 아깐 테이블스페이스에 저장 안한다며 8.0부터 -> 시스템 테이블 스페이스랑 언두테이블스페이는 다른듯

## 인덱스 업데이트를 위한 체인지 버퍼

    > 레코드 변경에는 인덱스 업데이트도 필요 -> 인덱스 업데이트에는 랜덤한 디스크 리딩이 필요해 비용 높음
    > 버퍼 풀에 인덱스 페이지가 있으면 업데이트
    > 버퍼 풀에 없다면 임시 메모리공간(체인지버퍼) 에 저장했다가 업데이트 (단, 유니크인덱스는 중복체크가 필요해 불가능)
    > 체인지 버퍼의 내역은 백그라운드 스레드(체인지 버퍼 머지 스레드)가 병합
    > 5.5 이전엔 인서트만 이런식으로 사용되서 인서트 버퍼라고도 불림
    > innodb_change_buffering 에 변수에 따라, 추가 삭제 업데이트 중 뭘 버퍼링 걸건지 정할 수 있음
    > 체인지 버퍼는 insert, update가 너무 빈번하면 사이즈를 늘릴 수 있으며 기본적으론 버퍼풀의 25~50%

## 영속성 듀러블을 위해 리두로그와 로그 버퍼

    > 비정상 종료등의 상황에서 미처 기록되지 못한 아이들을 가지고 있다.
    > 모든 DBMS는 쓰기보다 읽기를 고려하고 있어, 파일 쓰기는 디스크 랜덤 엑세스가 필요하며 이에 쓰기 비용이 낮은 자료구조인 리두 로그로 먼저 기록한다.
    > 리두로그는 1. 커밋되었지만 기록되지 않은 데이터. 2. 롤백되었지만 이미 기록된 데이터 들을 위해 존재한다.
    > 1.은 리두로그 내역을 기록하면 되고, 2는 리두로그로 상황을 파악하고 언두로그로 원복시킨다.

```mysql
innodb_flush_log_at_trx_commit = 0 -- `약 1초에 한번 리두를 디스크로 동기화 하는 주기를 가진다. 최대 1초까지는 트랜젝션은 커밋은 했지만 디스크에는 아직 안올리고 리두에만 있다가 비정상 종료되면 디스크에는 없을 수 있다. ?? 아니 리두로그내역도 사라지는겨?? 아니면 리두로그가 있으니 복구 될 수 있나?
= 1 --매 커밋마다 리두는 디스크로 올린다. 때문에 변경한 데이터는 사라진다 - 이건 언두로그의 데이터 아닌겨?
= 2 --매 커밋마다 디스크로 적지만 동기화는 1초마다, 따라서 mysql 서버는 죽고 운영체제가 살아있으면 트렌젝션 데이터는 살아있다.?? 뭔말이야 이짐 적었다며
```

    > 8버전부터 리두로그 끌 수 있으며 대용량 데이터 적재등에서 적재시간 단축이 가능하다.
    > 단 재 활성화를 안해준다면, 비정상 종료 후에 재시작 되면 서버마다 다른 데이터 시점을 가지게 된다. 따라서 비활보다는 일부 손실이 있어도 된다면 시스템 변수를 0이나 2로 해서 쓰자

## 버퍼 풀에 빠르게 접근하는 어댑티브 해시 인덱스

    > 일반적인 인덱스는 테이블에 사용자가 세팅해둔 b-tree 를 의미한다.
    > 어댑티브 해시 인덱스는 innodb 스토리지가 사용자가 자주 쓰는 데이터에 대한 자동 생성한 인덱스로, 끄고 킬 수 있다.
    > b-tree는 빠르다 불릴 수 있지만, 엄청나게 많은 요청에 대해서는 부족 할 수 있다. 이에 맞게 자주 읽히는 데이이터 페이지 키 값으로 해시 인덱스를 만들고 즉시 찾아가는 방식을 가진다. -> 리프노드까지 찾아가지 않고 바로 찾아가는! -> 내부잠금(세마포어) 경합도 획기적으로 준다!
    > b-tree 인덱스 고유 번호와 실제 키값의 조합
    > 8.0부터는 어댑티브 해시 인덱스의 파티션 기능 제공
    > 다음과 같은 경우 이득 :
        1. 디스크 읽기가 많지 않은, 디스크데이터 크기 = 버퍼풀 크기
        2. 동등 조건 =, in 검색이 많은 경우
        3. 쿼리가 데이터 중 일부에만 집중되는경우
        ???왜
    > 다음에서 손해 :
        1. 디스크 읽기가 많은 경우
        2. 조인이나 like 많은 경우
        3. 매우 큰 데이터를 가진 테이블의 데이터 폭이 넓게 읽는 경우
    > 요점은 버퍼 풀 내에서 빠른접근을 더 빠르게 해준 다는 것
    > 단, 사용하게 되면 이 인덱스부터 찾느라 효용이 없어도 찾을 거란 것
    > 단, 테이블 변경 및 삭제에도 어댑티프 해시 인덱스가 걸려있으면 다 제거하고 처리해야 해서 비용이 많이 든다는 것.

## 스토리지 엔진간 비교 간단히

'8.0 부터는 innodb 가 짱임'
